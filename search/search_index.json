{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>Provides Django model utilities for encouraging direct data access instead of unnecessary object overhead. Implemented through compatible method and operator extensions<sup>1</sup> to QuerySets and Managers.</p> <p>The primary motivation is the experiential observation that the active record pattern - specifically <code>Model.save</code> - is the root of all evil. The secondary goal is to provide a more intuitive data layer, similar to dataframes.</p> <p>Usage: instantiate the custom manager in your models.</p>"},{"location":"#updates","title":"Updates","text":"<p>The Bad:</p> <pre><code>book = Book.objects.get(pk=pk)\nbook.rating = 5.0\nbook.save()\n</code></pre> <p>This example is ubiquitous and even encouraged in many django circles. It's also an epic fail:</p> <ul> <li>Runs an unnecessary select query, as no fields need to be read.</li> <li>Updates all fields instead of just the one needed.</li> <li>Therefore also suffers from race conditions.</li> <li>And is relatively verbose, without addressing errors yet.</li> </ul> <p>The solution is relatively well-known, and endorsed by django's own docs, but remains under-utilized.</p> <p>The Ugly:</p> <pre><code>Book.objects.filter(pk=pk).update(rating=5.0)\n</code></pre> <p>So why not provide syntactic support for the better approach? The Manager supports filtering by primary key, since that's so common. The QuerySet supports column updates.</p> <p>The Good:</p> <pre><code>Book.objects[pk]['rating'] = 5.0\n</code></pre> <p>But one might posit...</p> <ul> <li>\"Isn't the encapsulation <code>save</code> provides worth it in principle?\"</li> <li>\"Doesn't the <code>update_fields</code> option fix this in practice?\"</li> <li>\"What if the object is cached or has custom logic in the <code>save</code> method?\"</li> </ul> <p>No, no, and good luck with that.<sup>2</sup> Consider a more realistic example which addresses these concerns.</p> <p>The Bad:</p> <pre><code>try:\n    book = Book.objects.get(pk=pk)\nexcept Book.DoesNotExist:\n    changed = False\nelse:\n    changed = book.publisher != publisher\n    if changed:\n        book.publisher = publisher\n        book.pubdate = today\n        book.save(update_fields=['publisher', 'pubdate'])\n</code></pre> <p>This solves the most severe problem, though with more verbosity and still an unnecessary read.<sup>3</sup> Note handling <code>pubdate</code> in the <code>save</code> implementation would only spare the caller one line of code. But the real problem is how to handle custom logic when <code>update_fields</code> isn't specified. There's no one obvious correct behavior, which is why projects like django-model-utils have to track the changes on the object itself.<sup>4</sup></p> <p>A better approach would be an <code>update_publisher</code> method which does all and only what is required. So what would such an implementation be? A straight-forward update won't work, yet only a minor tweak is needed.</p> <p>The Ugly:</p> <pre><code>changed = Book.objects.filter(pk=pk).exclude(publisher=publisher) \\ \n    .update(publisher=publisher, pubdate=today)\n</code></pre> <p>Now the update is only executed if necessary. And this can be generalized with a little inspiration from <code>{get,update}_or_create</code>.</p> <p>The Good:</p> <pre><code>changed = Book.objects[pk].change({'pubdate': today}, publisher=publisher)\n</code></pre>"},{"location":"#selects","title":"Selects","text":"<p>Direct column access has some of the clunkiest syntax: <code>values_list(..., flat=True)</code>. QuerySets override <code>__getitem__</code>, as well as comparison operators for simple filters. Both are common syntax in panel data layers.</p> <p>The Bad:</p> <pre><code>{book.pk: book.name for book in qs}\n\n(book.name for book in qs.filter(name__isnull=False))\n\nif qs.filter(author=author):\n</code></pre> <p>The Ugly:</p> <pre><code>dict(qs.values_list('pk', 'name'))\n\nqs.exclude(name=None).values_list('name', flat=True)\n\nif qs.filter(author=author).exists():\n</code></pre> <p>The Good:</p> <pre><code>dict(qs['pk', 'name'])\n\nqs['name'] != None\n\nif author in qs['author']:\n</code></pre>"},{"location":"#aggregation","title":"Aggregation","text":"<p>Once accustomed to working with data values, a richer set of aggregations becomes possible. The method names mirror projects like ibis whenever applicable.</p> <p>The Bad:</p> <pre><code>collections.Counter(book.author for book in qs)\n\nsum(book.rating for book in qs) / len(qs)\n\ncounts = collections.Counter()\nfor book in qs:\n    counts[book.author] += book.quantity\n</code></pre> <p>The Ugly:</p> <pre><code>dict(qs.values_list('author').annotate(model.Count('author')))\n\nqs.aggregate(models.Avg('rating'))['rating__avg']\n\ndict(qs.values_list('author').annotate(models.Sum('quantity')))\n</code></pre> <p>The Good:</p> <pre><code>dict(qs['author'].value_counts())\n\nqs['rating'].mean()\n\ndict(qs['quantity'].group_by('author').sum())\n</code></pre>"},{"location":"#expressions","title":"Expressions","text":"<p><code>F</code> expressions are similarly extended to easily create <code>Q</code>, <code>Func</code>, and <code>OrderBy</code> objects. Note they can be used directly even without a custom manager.</p> <p>The Bad:</p> <pre><code>(book for book in qs if book.author.startswith('A') or book.author.startswith('B'))\n\n(book.title[:10] for book in qs)\n\nfor book in qs:\n    book.rating += 1\n    book.save()\n</code></pre> <p>The Ugly:</p> <pre><code>qs.filter(Q(author__startswith='A') | Q(author__startswith='B'))\n\nqs.values_list(functions.Substr('title', 1, 10), flat=True)\n\nqs.update(rating=models.F('rating') + 1)\n</code></pre> <p>The Good:</p> <pre><code>qs[F.any(map(F.author.startswith, 'AB'))]\n\nqs[F.title[:10]]\n\nqs['rating'] += 1\n</code></pre>"},{"location":"#conditionals","title":"Conditionals","text":"<p>Annotations and updates with <code>Case</code> and <code>When</code> expressions. See also bulk_changed and bulk_change for efficient bulk operations on primary keys.</p> <p>The Bad:</p> <pre><code>collections.Counter('low' if book.quantity &lt; 10 else 'high' for book in qs).items()\n\nfor author, quantity in items:\n    for book in qs.filter(author=author):\n        book.quantity = quantity\n        book.save()\n</code></pre> <p>The Ugly:</p> <pre><code>qs.values_list(models.Case(\n    models.When(quantity__lt=10, then=models.Value('low')),\n    models.When(quantity__gte=10, then=models.Value('high')),\n    output_field=models.CharField(),\n)).annotate(count=models.Count('*'))\n\ncases = (models.When(author=author, then=models.Value(quantity)) for author, quantity in items)\nqs.update(quantity=models.Case(*cases, default='quantity'))\n</code></pre> <p>The Good:</p> <pre><code>qs[{F.quantity &lt; 10: 'low', F.quantity &gt;= 10: 'high'}].value_counts()\n\nqs['quantity'] = {F.author == author: quantity for author, quantity in items}\n</code></pre> <ol> <li> <p>The only incompatible changes are edge cases which aren't documented behavior, such as queryset comparison.\u00a0\u21a9</p> </li> <li> <p>In the vast majority of instances of that idiom, the object is immediately discarded and no custom logic is necessary. Furthermore the dogma of a model knowing how to serialize itself doesn't inherently imply a single all-purpose instance method. Specialized classmethods or manager methods would be just as encapsulated.\u00a0\u21a9</p> </li> <li> <p>Premature optimization? While debatable with respect to general object overhead, nothing good can come from running superfluous database queries.\u00a0\u21a9</p> </li> <li> <p>Supporting <code>update_fields</code> with custom logic also results in complex conditionals, ironic given that OO methodology ostensibly favors separate methods over large switch statements.\u00a0\u21a9</p> </li> </ol>"},{"location":"example/","title":"Example","text":"<p>An example <code>Model</code> used in the tests.</p> <pre><code>from django.db import models\nfrom model_values import F, Manager, classproperty\n\n\nclass Book(models.Model):\n    title = models.TextField()\n    author = models.CharField(max_length=50)\n    quantity = models.IntegerField()\n    last_modified = models.DateTimeField(auto_now=True)\n\n    objects = Manager()\n</code></pre>"},{"location":"example/#table-logic","title":"Table logic","text":"<p>Django recommends model methods for row-level functionality, and custom managers for table-level functionality. That's fine if the custom managers are reused across models, but often they're just custom filters, and specific to a model. As evidenced by django-model-utils' <code>QueryManager</code>.</p> <p>There's a simpler way to achieve the same end: a model <code>classmethod</code>. In some cases a profileration of classmethods is an anti-pattern, but in this case functions won't suffice. It's Django that attached the <code>Manager</code> instance to a class.</p> <p>Additionally a <code>classproperty</code> wrapper is provided, to mimic a custom <code>Manager</code> or <code>Queryset</code> without calling it first.</p> <pre><code>    @classproperty\n    def in_stock(cls):\n        return cls.objects.filter(F.quantity &gt; 0)\n</code></pre>"},{"location":"example/#row-logic","title":"Row logic","text":"<p>Some of the below methods may be added to a model mixin in the future. It's a delicate balance, as the goal is to not encourage object usage. However, sometimes having an object already is inevitable, so it's still worth considering best practices given that situation.</p> <p>Providing wrappers for any manager method that's <code>pk</code>-based may be worthwhile, particularly a filter to match only the object.</p> <pre><code>    @property\n    def object(self):\n        return type(self).objects[self.pk]\n</code></pre> <p>From there one can easily imagine other useful extensions.</p> <pre><code>    def changed(self, **kwargs):\n        return self.object.changed(**kwargs)\n\n    def update(self, **kwargs):\n        for name in kwargs:\n            setattr(self, name, kwargs[name])\n        return self.object.update(**kwargs)\n</code></pre>"},{"location":"reference/","title":"Reference","text":"<p>Note</p> <p>Spatial lookups require gis to be enabled.</p> <p>Note</p> <p>Since attributes are used for constructing F objects, there may be collisions between field names and methods. For example, <code>name</code> is a reserved attribute, but the usual constructor can still be used: <code>F('name')</code>.</p> <p>Note</p> <p>See source for available spatial functions if gis is configured.</p> <p>Note</p> <p>See source for available aggregate spatial functions if gis is configured.</p>"},{"location":"reference/#model_values.Lookup","title":"<code>model_values.Lookup</code>","text":"<p>Mixin for field lookups.</p> Source code in <code>model_values/__init__.py</code> <pre><code>class Lookup:\n    \"\"\"Mixin for field lookups.\"\"\"\n\n    __ne__ = eq('ne')\n    __lt__ = eq('lt')\n    __le__ = eq('lte')\n    __gt__ = eq('gt')\n    __ge__ = eq('gte')\n    iexact = eq('iexact')\n    icontains = eq('icontains')\n    startswith = eq('startswith')\n    istartswith = eq('istartswith')\n    endswith = eq('endswith')\n    iendswith = eq('iendswith')\n    regex = eq('regex')\n    iregex = eq('iregex')\n    isin = eq('in')\n    # spatial lookups\n    contained = eq('contained')\n    coveredby = eq('coveredby')\n    covers = eq('covers')\n    crosses = eq('crosses')\n    disjoint = eq('disjoint')\n    equals = eq('equals')  # __eq__ is taken\n    intersects = eq('intersects')  # __and__ is ambiguous\n    touches = eq('touches')\n    __lshift__ = left = eq('left')\n    __rshift__ = right = eq('right')\n    above = eq('strictly_above')\n    below = eq('strictly_below')\n\n    def range(self, *values):\n        \"\"\"range\"\"\"\n        return self.__eq__(values, '__range')\n\n    def relate(self, *values):\n        \"\"\"relate\"\"\"\n        return self.__eq__(values, '__relate')\n\n    @property\n    def is_valid(self):\n        \"\"\"Whether field `isvalid`.\"\"\"\n        return self.__eq__(True, '__isvalid')\n\n    def contains(self, value, properly=False, bb=False):\n        \"\"\"Return whether field `contains` the value.  Options apply only to geom fields.\n\n        Args:\n            properly: `contains_properly`\n            bb: bounding box, `bbcontains`\n        \"\"\"\n        properly = '_properly' * bool(properly)\n        bb = 'bb' * bool(bb)\n        return self.__eq__(value, f'__{bb}contains{properly}')\n\n    def overlaps(self, geom, position='', bb=False):\n        \"\"\"Return whether field `overlaps` with geometry .\n\n        Args:\n            position: `overlaps_{left, right, above, below}`\n            bb: bounding box, `bboverlaps`\n        \"\"\"\n        bb = 'bb' * bool(bb)\n        return self.__eq__(geom, f'__{bb}overlaps_{position}'.rstrip('_'))\n\n    def within(self, geom, distance=None):\n        \"\"\"Return whether field is `within` geometry.\n\n        Args:\n            distance: `dwithin`\n        \"\"\"\n        if distance is None:\n            return self.__eq__(geom, '__within')\n        return self.__eq__((geom, distance), '__dwithin')\n</code></pre>"},{"location":"reference/#model_values.Lookup.is_valid","title":"<code>is_valid</code>  <code>property</code>","text":"<p>Whether field <code>isvalid</code>.</p>"},{"location":"reference/#model_values.Lookup.contains","title":"<code>contains(value, properly=False, bb=False)</code>","text":"<p>Return whether field <code>contains</code> the value.  Options apply only to geom fields.</p> <p>Parameters:</p> Name Type Description Default <code>properly</code> <p><code>contains_properly</code></p> <code>False</code> <code>bb</code> <p>bounding box, <code>bbcontains</code></p> <code>False</code> Source code in <code>model_values/__init__.py</code> <pre><code>def contains(self, value, properly=False, bb=False):\n    \"\"\"Return whether field `contains` the value.  Options apply only to geom fields.\n\n    Args:\n        properly: `contains_properly`\n        bb: bounding box, `bbcontains`\n    \"\"\"\n    properly = '_properly' * bool(properly)\n    bb = 'bb' * bool(bb)\n    return self.__eq__(value, f'__{bb}contains{properly}')\n</code></pre>"},{"location":"reference/#model_values.Lookup.overlaps","title":"<code>overlaps(geom, position='', bb=False)</code>","text":"<p>Return whether field <code>overlaps</code> with geometry .</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <p><code>overlaps_{left, right, above, below}</code></p> <code>''</code> <code>bb</code> <p>bounding box, <code>bboverlaps</code></p> <code>False</code> Source code in <code>model_values/__init__.py</code> <pre><code>def overlaps(self, geom, position='', bb=False):\n    \"\"\"Return whether field `overlaps` with geometry .\n\n    Args:\n        position: `overlaps_{left, right, above, below}`\n        bb: bounding box, `bboverlaps`\n    \"\"\"\n    bb = 'bb' * bool(bb)\n    return self.__eq__(geom, f'__{bb}overlaps_{position}'.rstrip('_'))\n</code></pre>"},{"location":"reference/#model_values.Lookup.range","title":"<code>range(*values)</code>","text":"<p>range</p> Source code in <code>model_values/__init__.py</code> <pre><code>def range(self, *values):\n    \"\"\"range\"\"\"\n    return self.__eq__(values, '__range')\n</code></pre>"},{"location":"reference/#model_values.Lookup.relate","title":"<code>relate(*values)</code>","text":"<p>relate</p> Source code in <code>model_values/__init__.py</code> <pre><code>def relate(self, *values):\n    \"\"\"relate\"\"\"\n    return self.__eq__(values, '__relate')\n</code></pre>"},{"location":"reference/#model_values.Lookup.within","title":"<code>within(geom, distance=None)</code>","text":"<p>Return whether field is <code>within</code> geometry.</p> <p>Parameters:</p> Name Type Description Default <code>distance</code> <p><code>dwithin</code></p> <code>None</code> Source code in <code>model_values/__init__.py</code> <pre><code>def within(self, geom, distance=None):\n    \"\"\"Return whether field is `within` geometry.\n\n    Args:\n        distance: `dwithin`\n    \"\"\"\n    if distance is None:\n        return self.__eq__(geom, '__within')\n    return self.__eq__((geom, distance), '__dwithin')\n</code></pre>"},{"location":"reference/#model_values.F","title":"<code>model_values.F</code>","text":"<p>               Bases: <code>F</code>, <code>Lookup</code></p> <p>Create <code>F</code>, <code>Q</code>, and <code>Func</code> objects with expressions.</p> <p><code>F</code> creation supported as attributes: <code>F.user</code> == <code>F('user')</code>, <code>F.user.created</code> == <code>F('user__created')</code>.</p> <p><code>Q</code> lookups supported as methods or operators: <code>F.text.iexact(...)</code> == <code>Q(text__iexact=...)</code>, <code>F.user.created &gt;= ...</code> == <code>Q(user__created__gte=...)</code>.</p> <p><code>Func</code> objects also supported as methods: <code>F.user.created.min()</code> == <code>Min('user__created')</code>.</p> <p>Some <code>Func</code> objects can also be transformed into lookups, if registered: <code>F.text.length()</code> == <code>Length(F('text'))</code>, <code>F.text.length &gt; 0</code> == <code>Q(text__length__gt=0)</code>.</p> Source code in <code>model_values/__init__.py</code> <pre><code>class F(models.F, Lookup, metaclass=MetaF):\n    \"\"\"Create `F`, `Q`, and `Func` objects with expressions.\n\n    `F` creation supported as attributes:\n    `F.user` == `F('user')`,\n    `F.user.created` == `F('user__created')`.\n\n    `Q` lookups supported as methods or operators:\n    `F.text.iexact(...)` == `Q(text__iexact=...)`,\n    `F.user.created &gt;= ...` == `Q(user__created__gte=...)`.\n\n    `Func` objects also supported as methods:\n    `F.user.created.min()` == `Min('user__created')`.\n\n    Some `Func` objects can also be transformed into lookups,\n    if [registered](https://docs.djangoproject.com/en/stable/ref/models/database-functions/#length):\n    `F.text.length()` == `Length(F('text'))`,\n    `F.text.length &gt; 0` == `Q(text__length__gt=0)`.\n    \"\"\"\n\n    lookups = dict(\n        length=functions.Length,\n        lower=functions.Lower,\n        upper=functions.Upper,\n        chr=functions.Chr,\n        ord=functions.Ord,\n        acos=functions.ACos,\n        asin=functions.ASin,\n        atan=functions.ATan,\n        atan2=functions.ATan2,\n        cos=functions.Cos,\n        cot=functions.Cot,\n        degrees=functions.Degrees,\n        exp=functions.Exp,\n        radians=functions.Radians,\n        sin=functions.Sin,\n        sqrt=functions.Sqrt,\n        tan=functions.Tan,\n        sign=functions.Sign,\n        md5=functions.MD5,\n    )\n    coalesce = method(functions.Coalesce)\n    concat = method(functions.Concat)  # __add__ is taken\n    min = method(models.Min)\n    max = method(models.Max)\n    sum = method(models.Sum)\n    mean = method(models.Avg)\n    var = method(models.Variance)\n    std = method(models.StdDev)\n    greatest = method(functions.Greatest)\n    least = method(functions.Least)\n    now = staticmethod(functions.Now)\n    cast = method(functions.Cast)\n    extract = method(functions.Extract)\n    trunc = method(functions.Trunc)\n    cume_dist = method(functions.CumeDist)\n    dense_rank = method(functions.DenseRank)\n    first_value = method(functions.FirstValue)\n    lag = method(functions.Lag)\n    last_value = method(functions.LastValue)\n    lead = method(functions.Lead)\n    nth_value = method(functions.NthValue)\n    ntile = staticmethod(functions.Ntile)\n    percent_rank = method(functions.PercentRank)\n    rank = method(functions.Rank)\n    row_number = method(functions.RowNumber)\n    strip = method(functions.Trim)\n    lstrip = method(functions.LTrim)\n    rstrip = method(functions.RTrim)\n    repeat = method(functions.Repeat)\n    nullif = method(functions.NullIf)\n    __reversed__ = method(functions.Reverse)\n    __abs__ = method(functions.Abs)\n    __ceil__ = method(functions.Ceil)\n    __floor__ = method(functions.Floor)\n    __mod__ = method(functions.Mod)\n    pi = functions.Pi()\n    __pow__ = method(functions.Power)\n    __round__ = method(functions.Round)\n    sha1 = method(functions.SHA1)\n    sha224 = method(functions.SHA224)\n    sha256 = method(functions.SHA256)\n    sha384 = method(functions.SHA384)\n    sha512 = method(functions.SHA512)\n    collate = method(functions.Collate)\n    json = staticmethod(functions.JSONObject)\n    random = staticmethod(functions.Random)\n    if gis:  # pragma: no cover\n        area = property(gis.functions.Area)\n        geojson = method(gis.functions.AsGeoJSON)\n        gml = method(gis.functions.AsGML)\n        kml = method(gis.functions.AsKML)\n        svg = method(gis.functions.AsSVG)\n        bounding_circle = method(gis.functions.BoundingCircle)\n        centroid = property(gis.functions.Centroid)\n        difference = method(gis.functions.Difference)\n        envelope = property(gis.functions.Envelope)\n        geohash = method(gis.functions.GeoHash)  # __hash__ requires an int\n        intersection = method(gis.functions.Intersection)\n        make_valid = method(gis.functions.MakeValid)\n        mem_size = property(gis.functions.MemSize)\n        num_geometries = property(gis.functions.NumGeometries)\n        num_points = property(gis.functions.NumPoints)\n        perimeter = property(gis.functions.Perimeter)\n        point_on_surface = property(gis.functions.PointOnSurface)\n        reverse = method(gis.functions.Reverse)\n        scale = method(gis.functions.Scale)\n        snap_to_grid = method(gis.functions.SnapToGrid)\n        symmetric_difference = method(gis.functions.SymDifference)\n        transform = method(gis.functions.Transform)\n        translate = method(gis.functions.Translate)\n        union = method(gis.functions.Union)\n        azimuth = method(gis.functions.Azimuth)\n        line_locate_point = method(gis.functions.LineLocatePoint)\n        force_polygon_cw = method(gis.functions.ForcePolygonCW)\n\n        @method\n        class distance(gis.functions.Distance):\n            \"\"\"Return `Distance` with support for lookups: &lt;, &lt;=, &gt;, &gt;=, within.\"\"\"\n\n            __lt__ = method(transform, 'distance_lt')\n            __le__ = method(transform, 'distance_lte')\n            __gt__ = method(transform, 'distance_gt')\n            __ge__ = method(transform, 'distance_gte')\n            within = method(transform, 'dwithin')\n\n    def __getattr__(self, name: str) -&gt; F:\n        \"\"\"Return new [F][model_values.F] object with chained attribute.\"\"\"\n        return type(self)(f'{self.name}__{name}')\n\n    def __eq__(self, value, lookup: str = '') -&gt; models.Q:\n        \"\"\"Return `Q` object with lookup.\"\"\"\n        if not lookup and type(value) is models.F:\n            return self.name == value.name\n        return models.Q(**{self.name + lookup: value})\n\n    def __ne__(self, value) -&gt; models.Q:\n        \"\"\"Allow __ne=None lookup without custom queryset.\"\"\"\n        if value is None:\n            return self.__eq__(False, '__isnull')\n        return self.__eq__(value, '__ne')\n\n    __hash__ = models.F.__hash__\n\n    def __call__(self, *args, **extra) -&gt; models.Func:\n        name, _, func = self.name.rpartition('__')\n        return self.lookups[func](name, *args, **extra)\n\n    def __iter__(self):\n        raise TypeError(\"'F' object is not iterable\")\n\n    def __getitem__(self, slc: slice) -&gt; models.Func:\n        \"\"\"Return field `Substr` or `Right`.\"\"\"\n        assert (slc.stop or 0) &gt;= 0 and slc.step is None\n        start = slc.start or 0\n        if start &lt; 0:\n            assert slc.stop is None\n            return functions.Right(self, -start)\n        size = slc.stop and max(slc.stop - start, 0)\n        return functions.Substr(self, start + 1, size)\n\n    def __rmod__(self, value):\n        return functions.Mod(value, self)\n\n    def __rpow__(self, value):\n        return functions.Power(value, self)\n\n    @method\n    def count(self='*', **extra):\n        \"\"\"Return `Count` with optional field.\"\"\"\n        return models.Count(getattr(self, 'name', self), **extra)\n\n    def find(self, sub, **extra) -&gt; models.Expression:\n        \"\"\"Return `StrIndex` with `str.find` semantics.\"\"\"\n        return functions.StrIndex(self, Value(sub), **extra) - 1\n\n    def replace(self, old, new='', **extra) -&gt; models.Func:\n        \"\"\"Return `Replace` with wrapped values.\"\"\"\n        return functions.Replace(self, Value(old), Value(new), **extra)\n\n    def ljust(self, width: int, fill=' ', **extra) -&gt; models.Func:\n        \"\"\"Return `LPad` with wrapped values.\"\"\"\n        return functions.LPad(self, width, Value(fill), **extra)\n\n    def rjust(self, width: int, fill=' ', **extra) -&gt; models.Func:\n        \"\"\"Return `RPad` with wrapped values.\"\"\"\n        return functions.RPad(self, width, Value(fill), **extra)\n\n    def log(self, base=math.e, **extra) -&gt; models.Func:\n        \"\"\"Return `Log`, by default `Ln`.\"\"\"\n        return functions.Log(self, base, **extra)\n</code></pre>"},{"location":"reference/#model_values.F.distance","title":"<code>distance</code>","text":"<p>               Bases: <code>Distance</code></p> <p>Return <code>Distance</code> with support for lookups: &lt;, &lt;=, &gt;, &gt;=, within.</p> Source code in <code>model_values/__init__.py</code> <pre><code>@method\nclass distance(gis.functions.Distance):\n    \"\"\"Return `Distance` with support for lookups: &lt;, &lt;=, &gt;, &gt;=, within.\"\"\"\n\n    __lt__ = method(transform, 'distance_lt')\n    __le__ = method(transform, 'distance_lte')\n    __gt__ = method(transform, 'distance_gt')\n    __ge__ = method(transform, 'distance_gte')\n    within = method(transform, 'dwithin')\n</code></pre>"},{"location":"reference/#model_values.F.__eq__","title":"<code>__eq__(value, lookup='')</code>","text":"<p>Return <code>Q</code> object with lookup.</p> Source code in <code>model_values/__init__.py</code> <pre><code>def __eq__(self, value, lookup: str = '') -&gt; models.Q:\n    \"\"\"Return `Q` object with lookup.\"\"\"\n    if not lookup and type(value) is models.F:\n        return self.name == value.name\n    return models.Q(**{self.name + lookup: value})\n</code></pre>"},{"location":"reference/#model_values.F.__getattr__","title":"<code>__getattr__(name)</code>","text":"<p>Return new F object with chained attribute.</p> Source code in <code>model_values/__init__.py</code> <pre><code>def __getattr__(self, name: str) -&gt; F:\n    \"\"\"Return new [F][model_values.F] object with chained attribute.\"\"\"\n    return type(self)(f'{self.name}__{name}')\n</code></pre>"},{"location":"reference/#model_values.F.__getitem__","title":"<code>__getitem__(slc)</code>","text":"<p>Return field <code>Substr</code> or <code>Right</code>.</p> Source code in <code>model_values/__init__.py</code> <pre><code>def __getitem__(self, slc: slice) -&gt; models.Func:\n    \"\"\"Return field `Substr` or `Right`.\"\"\"\n    assert (slc.stop or 0) &gt;= 0 and slc.step is None\n    start = slc.start or 0\n    if start &lt; 0:\n        assert slc.stop is None\n        return functions.Right(self, -start)\n    size = slc.stop and max(slc.stop - start, 0)\n    return functions.Substr(self, start + 1, size)\n</code></pre>"},{"location":"reference/#model_values.F.__ne__","title":"<code>__ne__(value)</code>","text":"<p>Allow __ne=None lookup without custom queryset.</p> Source code in <code>model_values/__init__.py</code> <pre><code>def __ne__(self, value) -&gt; models.Q:\n    \"\"\"Allow __ne=None lookup without custom queryset.\"\"\"\n    if value is None:\n        return self.__eq__(False, '__isnull')\n    return self.__eq__(value, '__ne')\n</code></pre>"},{"location":"reference/#model_values.F.count","title":"<code>count(**extra)</code>","text":"<p>Return <code>Count</code> with optional field.</p> Source code in <code>model_values/__init__.py</code> <pre><code>@method\ndef count(self='*', **extra):\n    \"\"\"Return `Count` with optional field.\"\"\"\n    return models.Count(getattr(self, 'name', self), **extra)\n</code></pre>"},{"location":"reference/#model_values.F.find","title":"<code>find(sub, **extra)</code>","text":"<p>Return <code>StrIndex</code> with <code>str.find</code> semantics.</p> Source code in <code>model_values/__init__.py</code> <pre><code>def find(self, sub, **extra) -&gt; models.Expression:\n    \"\"\"Return `StrIndex` with `str.find` semantics.\"\"\"\n    return functions.StrIndex(self, Value(sub), **extra) - 1\n</code></pre>"},{"location":"reference/#model_values.F.ljust","title":"<code>ljust(width, fill=' ', **extra)</code>","text":"<p>Return <code>LPad</code> with wrapped values.</p> Source code in <code>model_values/__init__.py</code> <pre><code>def ljust(self, width: int, fill=' ', **extra) -&gt; models.Func:\n    \"\"\"Return `LPad` with wrapped values.\"\"\"\n    return functions.LPad(self, width, Value(fill), **extra)\n</code></pre>"},{"location":"reference/#model_values.F.log","title":"<code>log(base=math.e, **extra)</code>","text":"<p>Return <code>Log</code>, by default <code>Ln</code>.</p> Source code in <code>model_values/__init__.py</code> <pre><code>def log(self, base=math.e, **extra) -&gt; models.Func:\n    \"\"\"Return `Log`, by default `Ln`.\"\"\"\n    return functions.Log(self, base, **extra)\n</code></pre>"},{"location":"reference/#model_values.F.replace","title":"<code>replace(old, new='', **extra)</code>","text":"<p>Return <code>Replace</code> with wrapped values.</p> Source code in <code>model_values/__init__.py</code> <pre><code>def replace(self, old, new='', **extra) -&gt; models.Func:\n    \"\"\"Return `Replace` with wrapped values.\"\"\"\n    return functions.Replace(self, Value(old), Value(new), **extra)\n</code></pre>"},{"location":"reference/#model_values.F.rjust","title":"<code>rjust(width, fill=' ', **extra)</code>","text":"<p>Return <code>RPad</code> with wrapped values.</p> Source code in <code>model_values/__init__.py</code> <pre><code>def rjust(self, width: int, fill=' ', **extra) -&gt; models.Func:\n    \"\"\"Return `RPad` with wrapped values.\"\"\"\n    return functions.RPad(self, width, Value(fill), **extra)\n</code></pre>"},{"location":"reference/#model_values.QuerySet","title":"<code>model_values.QuerySet</code>","text":"<p>               Bases: <code>QuerySet</code>, <code>Lookup</code></p> Source code in <code>model_values/__init__.py</code> <pre><code>class QuerySet(models.QuerySet, Lookup):\n    min = reduce(models.Min)\n    max = reduce(models.Max)\n    sum = reduce(models.Sum)\n    mean = reduce(models.Avg)\n    var = reduce(models.Variance)\n    std = reduce(models.StdDev)\n    __add__ = field(operator.add)\n    __sub__ = field(operator.sub)\n    __mul__ = field(operator.mul)\n    __truediv__ = field(operator.truediv)\n    __mod__ = field(operator.mod)\n    __pow__ = field(operator.pow)\n    if gis:  # pragma: no cover\n        collect = reduce(gis.Collect)\n        extent = reduce(gis.Extent)\n        extent3d = reduce(gis.Extent3D)\n        make_line = reduce(gis.MakeLine)\n        union = reduce(gis.Union)\n\n    @property\n    def _flat(self):\n        return issubclass(self._iterable_class, models.query.FlatValuesListIterable)\n\n    @property\n    def _named(self):\n        return issubclass(self._iterable_class, models.query.NamedValuesListIterable)\n\n    def __getitem__(self, key):\n        \"\"\"Allow column access by field names, expressions, or `F` objects.\n\n        `qs[field]` returns flat `values_list`\n\n        `qs[field, ...]` returns tupled `values_list`\n\n        `qs[Q_obj]` provisionally returns filtered [QuerySet][model_values.QuerySet]\n        \"\"\"\n        if isinstance(key, tuple):\n            return self.values_list(*map(extract, key), named=True)\n        key = extract(key)\n        if isinstance(key, (str, models.Expression)):\n            return self.values_list(key, flat=True)\n        if isinstance(key, models.Q):\n            return self.filter(key)\n        return super().__getitem__(key)\n\n    def __setitem__(self, key, value):\n        \"\"\"Update a single column.\"\"\"\n        self.update(**{key: value})\n\n    def __eq__(self, value, lookup: str = '') -&gt; QuerySet:\n        \"\"\"Return [QuerySet][model_values.QuerySet] filtered by comparison to given value.\"\"\"\n        (field,) = self._fields\n        return self.filter(**{field + lookup: value})\n\n    def __contains__(self, value):\n        \"\"\"Return whether value is present using `exists`.\"\"\"\n        if self._result_cache is None and self._flat:\n            return (self == value).exists()\n        return value in iter(self)\n\n    def __iter__(self):\n        \"\"\"Iteration extended to support [group_by][model_values.QuerySet.group_by].\"\"\"\n        if not hasattr(self, '_group_by'):\n            return super().__iter__()\n        size = len(self._group_by)\n        rows = self[self._group_by + self._fields].order_by(*self._group_by).iterator()\n        groups = itertools.groupby(rows, key=operator.itemgetter(*range(size)))\n        getter = operator.itemgetter(size if self._flat else slice(size, None))\n        if self._named:\n            Row = collections.namedtuple('Row', self._fields)\n            getter = lambda tup: Row(*tup[size:])  # noqa: E731\n        return ((key, map(getter, values)) for key, values in groups)\n\n    def select(self, *fields, **annotations) -&gt; QuerySet:\n        \"\"\"Return annotated `values_list`.\"\"\"\n        return self.annotate(**annotations)[fields + tuple(annotations)]\n\n    items = select  # deprecated name\n\n    def group_by(self, *fields, **annotations) -&gt; QuerySet:\n        \"\"\"Return a grouped [QuerySet][model_values.QuerySet].\n\n        The queryset is iterable in the same manner as `itertools.groupby`.\n        Additionally the [reduce][model_values.QuerySet.reduce] functions will return annotated querysets.\n        \"\"\"\n        qs = self.annotate(**annotations)\n        qs._group_by = fields + tuple(annotations)\n        return qs\n\n    groupby = group_by  # deprecated name\n\n    def annotate(self, *args, **kwargs) -&gt; QuerySet:\n        \"\"\"Annotate extended to also handle mapping values, as a [Case][model_values.Case] expression.\n\n        Args:\n            **kwargs: `field={Q_obj: value, ...}, ...`\n\n        As a provisional feature, an optional `default` key may be specified.\n        \"\"\"\n        for field, value in kwargs.items():\n            if Case.isa(value):\n                kwargs[field] = Case.defaultdict(value)\n        return super().annotate(*args, **kwargs)\n\n    def alias(self, *args, **kwargs) -&gt; QuerySet:\n        \"\"\"Alias extended to also handle mapping values, as a [Case][model_values.Case] expression.\n\n        Args:\n            **kwargs: `field={Q_obj: value, ...}, ...`\n        \"\"\"\n        for field, value in kwargs.items():\n            if Case.isa(value):\n                kwargs[field] = Case.defaultdict(value)\n        return super().alias(*args, **kwargs)\n\n    def value_counts(self, alias: str = 'count') -&gt; QuerySet:\n        \"\"\"Return annotated value counts.\"\"\"\n        return self.select(*self._fields, **{alias: F.count()})\n\n    def sort(self, reverse=False) -&gt; QuerySet:\n        \"\"\"Return [QuerySet][model_values.QuerySet] ordered by selected values.\"\"\"\n        qs = self.order_by(*self._fields)\n        return qs.reverse() if reverse else qs\n\n    sort_values = sort  # deprecated name\n\n    def reduce(self, *funcs, **extra):\n        \"\"\"Return aggregated values, or an annotated [QuerySet][model_values.QuerySet].\n\n        Args:\n            *funcs: aggregation function classes\n        \"\"\"\n        funcs = [func(field, **extra) for field, func in zip(self._fields, itertools.cycle(funcs))]\n        if hasattr(self, '_group_by'):\n            return self[self._group_by].annotate(*funcs)\n        names = [func.default_alias for func in funcs]\n        row = self.aggregate(*funcs)\n        if self._named:\n            return collections.namedtuple('Row', names)(**row)\n        return row[names[0]] if self._flat else tuple(map(row.__getitem__, names))\n\n    def update(self, **kwargs) -&gt; int:\n        \"\"\"Update extended to also handle mapping values, as a [Case][model_values.Case] expression.\n\n        Args:\n            **kwargs: `field={Q_obj: value, ...}, ...`\n        \"\"\"\n        for field, value in kwargs.items():\n            if Case.isa(value):\n                kwargs[field] = Case(value, default=F(field))\n        return super().update(**kwargs)\n\n    def change(self, defaults: Mapping = {}, **kwargs) -&gt; int:\n        \"\"\"Update and return number of rows that actually changed.\n\n        For triggering on-change logic without fetching first.\n\n        `if qs.change(status=...):` status actually changed\n\n        `qs.change({'last_modified': now}, status=...)` last_modified only updated if status updated\n\n        Args:\n            defaults: optional mapping which will be updated conditionally, as with `update_or_create`.\n        \"\"\"\n        return self.exclude(**kwargs).update(**dict(defaults, **kwargs))\n\n    def changed(self, **kwargs) -&gt; dict:\n        \"\"\"Return first mapping of fields and values which differ in the db.\n\n        Also efficient enough to be used in boolean contexts, instead of `exists`.\n        \"\"\"\n        row = self.exclude(**kwargs).values(*kwargs).first() or {}\n        return {field: value for field, value in row.items() if value != kwargs[field]}\n\n    def exists(self, count: int = 1) -&gt; bool:\n        \"\"\"Return whether there are at least the specified number of rows.\"\"\"\n        if count == 1:\n            return super().exists()\n        return (self[:count].count() if self._result_cache is None else len(self)) &gt;= count\n</code></pre>"},{"location":"reference/#model_values.QuerySet.__contains__","title":"<code>__contains__(value)</code>","text":"<p>Return whether value is present using <code>exists</code>.</p> Source code in <code>model_values/__init__.py</code> <pre><code>def __contains__(self, value):\n    \"\"\"Return whether value is present using `exists`.\"\"\"\n    if self._result_cache is None and self._flat:\n        return (self == value).exists()\n    return value in iter(self)\n</code></pre>"},{"location":"reference/#model_values.QuerySet.__eq__","title":"<code>__eq__(value, lookup='')</code>","text":"<p>Return QuerySet filtered by comparison to given value.</p> Source code in <code>model_values/__init__.py</code> <pre><code>def __eq__(self, value, lookup: str = '') -&gt; QuerySet:\n    \"\"\"Return [QuerySet][model_values.QuerySet] filtered by comparison to given value.\"\"\"\n    (field,) = self._fields\n    return self.filter(**{field + lookup: value})\n</code></pre>"},{"location":"reference/#model_values.QuerySet.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Allow column access by field names, expressions, or <code>F</code> objects.</p> <p><code>qs[field]</code> returns flat <code>values_list</code></p> <p><code>qs[field, ...]</code> returns tupled <code>values_list</code></p> <p><code>qs[Q_obj]</code> provisionally returns filtered QuerySet</p> Source code in <code>model_values/__init__.py</code> <pre><code>def __getitem__(self, key):\n    \"\"\"Allow column access by field names, expressions, or `F` objects.\n\n    `qs[field]` returns flat `values_list`\n\n    `qs[field, ...]` returns tupled `values_list`\n\n    `qs[Q_obj]` provisionally returns filtered [QuerySet][model_values.QuerySet]\n    \"\"\"\n    if isinstance(key, tuple):\n        return self.values_list(*map(extract, key), named=True)\n    key = extract(key)\n    if isinstance(key, (str, models.Expression)):\n        return self.values_list(key, flat=True)\n    if isinstance(key, models.Q):\n        return self.filter(key)\n    return super().__getitem__(key)\n</code></pre>"},{"location":"reference/#model_values.QuerySet.__iter__","title":"<code>__iter__()</code>","text":"<p>Iteration extended to support group_by.</p> Source code in <code>model_values/__init__.py</code> <pre><code>def __iter__(self):\n    \"\"\"Iteration extended to support [group_by][model_values.QuerySet.group_by].\"\"\"\n    if not hasattr(self, '_group_by'):\n        return super().__iter__()\n    size = len(self._group_by)\n    rows = self[self._group_by + self._fields].order_by(*self._group_by).iterator()\n    groups = itertools.groupby(rows, key=operator.itemgetter(*range(size)))\n    getter = operator.itemgetter(size if self._flat else slice(size, None))\n    if self._named:\n        Row = collections.namedtuple('Row', self._fields)\n        getter = lambda tup: Row(*tup[size:])  # noqa: E731\n    return ((key, map(getter, values)) for key, values in groups)\n</code></pre>"},{"location":"reference/#model_values.QuerySet.__setitem__","title":"<code>__setitem__(key, value)</code>","text":"<p>Update a single column.</p> Source code in <code>model_values/__init__.py</code> <pre><code>def __setitem__(self, key, value):\n    \"\"\"Update a single column.\"\"\"\n    self.update(**{key: value})\n</code></pre>"},{"location":"reference/#model_values.QuerySet.alias","title":"<code>alias(*args, **kwargs)</code>","text":"<p>Alias extended to also handle mapping values, as a Case expression.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p><code>field={Q_obj: value, ...}, ...</code></p> <code>{}</code> Source code in <code>model_values/__init__.py</code> <pre><code>def alias(self, *args, **kwargs) -&gt; QuerySet:\n    \"\"\"Alias extended to also handle mapping values, as a [Case][model_values.Case] expression.\n\n    Args:\n        **kwargs: `field={Q_obj: value, ...}, ...`\n    \"\"\"\n    for field, value in kwargs.items():\n        if Case.isa(value):\n            kwargs[field] = Case.defaultdict(value)\n    return super().alias(*args, **kwargs)\n</code></pre>"},{"location":"reference/#model_values.QuerySet.annotate","title":"<code>annotate(*args, **kwargs)</code>","text":"<p>Annotate extended to also handle mapping values, as a Case expression.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p><code>field={Q_obj: value, ...}, ...</code></p> <code>{}</code> <p>As a provisional feature, an optional <code>default</code> key may be specified.</p> Source code in <code>model_values/__init__.py</code> <pre><code>def annotate(self, *args, **kwargs) -&gt; QuerySet:\n    \"\"\"Annotate extended to also handle mapping values, as a [Case][model_values.Case] expression.\n\n    Args:\n        **kwargs: `field={Q_obj: value, ...}, ...`\n\n    As a provisional feature, an optional `default` key may be specified.\n    \"\"\"\n    for field, value in kwargs.items():\n        if Case.isa(value):\n            kwargs[field] = Case.defaultdict(value)\n    return super().annotate(*args, **kwargs)\n</code></pre>"},{"location":"reference/#model_values.QuerySet.change","title":"<code>change(defaults={}, **kwargs)</code>","text":"<p>Update and return number of rows that actually changed.</p> <p>For triggering on-change logic without fetching first.</p> <p><code>if qs.change(status=...):</code> status actually changed</p> <p><code>qs.change({'last_modified': now}, status=...)</code> last_modified only updated if status updated</p> <p>Parameters:</p> Name Type Description Default <code>defaults</code> <code>Mapping</code> <p>optional mapping which will be updated conditionally, as with <code>update_or_create</code>.</p> <code>{}</code> Source code in <code>model_values/__init__.py</code> <pre><code>def change(self, defaults: Mapping = {}, **kwargs) -&gt; int:\n    \"\"\"Update and return number of rows that actually changed.\n\n    For triggering on-change logic without fetching first.\n\n    `if qs.change(status=...):` status actually changed\n\n    `qs.change({'last_modified': now}, status=...)` last_modified only updated if status updated\n\n    Args:\n        defaults: optional mapping which will be updated conditionally, as with `update_or_create`.\n    \"\"\"\n    return self.exclude(**kwargs).update(**dict(defaults, **kwargs))\n</code></pre>"},{"location":"reference/#model_values.QuerySet.changed","title":"<code>changed(**kwargs)</code>","text":"<p>Return first mapping of fields and values which differ in the db.</p> <p>Also efficient enough to be used in boolean contexts, instead of <code>exists</code>.</p> Source code in <code>model_values/__init__.py</code> <pre><code>def changed(self, **kwargs) -&gt; dict:\n    \"\"\"Return first mapping of fields and values which differ in the db.\n\n    Also efficient enough to be used in boolean contexts, instead of `exists`.\n    \"\"\"\n    row = self.exclude(**kwargs).values(*kwargs).first() or {}\n    return {field: value for field, value in row.items() if value != kwargs[field]}\n</code></pre>"},{"location":"reference/#model_values.QuerySet.exists","title":"<code>exists(count=1)</code>","text":"<p>Return whether there are at least the specified number of rows.</p> Source code in <code>model_values/__init__.py</code> <pre><code>def exists(self, count: int = 1) -&gt; bool:\n    \"\"\"Return whether there are at least the specified number of rows.\"\"\"\n    if count == 1:\n        return super().exists()\n    return (self[:count].count() if self._result_cache is None else len(self)) &gt;= count\n</code></pre>"},{"location":"reference/#model_values.QuerySet.group_by","title":"<code>group_by(*fields, **annotations)</code>","text":"<p>Return a grouped QuerySet.</p> <p>The queryset is iterable in the same manner as <code>itertools.groupby</code>. Additionally the reduce functions will return annotated querysets.</p> Source code in <code>model_values/__init__.py</code> <pre><code>def group_by(self, *fields, **annotations) -&gt; QuerySet:\n    \"\"\"Return a grouped [QuerySet][model_values.QuerySet].\n\n    The queryset is iterable in the same manner as `itertools.groupby`.\n    Additionally the [reduce][model_values.QuerySet.reduce] functions will return annotated querysets.\n    \"\"\"\n    qs = self.annotate(**annotations)\n    qs._group_by = fields + tuple(annotations)\n    return qs\n</code></pre>"},{"location":"reference/#model_values.QuerySet.reduce","title":"<code>reduce(*funcs, **extra)</code>","text":"<p>Return aggregated values, or an annotated QuerySet.</p> <p>Parameters:</p> Name Type Description Default <code>*funcs</code> <p>aggregation function classes</p> <code>()</code> Source code in <code>model_values/__init__.py</code> <pre><code>def reduce(self, *funcs, **extra):\n    \"\"\"Return aggregated values, or an annotated [QuerySet][model_values.QuerySet].\n\n    Args:\n        *funcs: aggregation function classes\n    \"\"\"\n    funcs = [func(field, **extra) for field, func in zip(self._fields, itertools.cycle(funcs))]\n    if hasattr(self, '_group_by'):\n        return self[self._group_by].annotate(*funcs)\n    names = [func.default_alias for func in funcs]\n    row = self.aggregate(*funcs)\n    if self._named:\n        return collections.namedtuple('Row', names)(**row)\n    return row[names[0]] if self._flat else tuple(map(row.__getitem__, names))\n</code></pre>"},{"location":"reference/#model_values.QuerySet.select","title":"<code>select(*fields, **annotations)</code>","text":"<p>Return annotated <code>values_list</code>.</p> Source code in <code>model_values/__init__.py</code> <pre><code>def select(self, *fields, **annotations) -&gt; QuerySet:\n    \"\"\"Return annotated `values_list`.\"\"\"\n    return self.annotate(**annotations)[fields + tuple(annotations)]\n</code></pre>"},{"location":"reference/#model_values.QuerySet.sort","title":"<code>sort(reverse=False)</code>","text":"<p>Return QuerySet ordered by selected values.</p> Source code in <code>model_values/__init__.py</code> <pre><code>def sort(self, reverse=False) -&gt; QuerySet:\n    \"\"\"Return [QuerySet][model_values.QuerySet] ordered by selected values.\"\"\"\n    qs = self.order_by(*self._fields)\n    return qs.reverse() if reverse else qs\n</code></pre>"},{"location":"reference/#model_values.QuerySet.update","title":"<code>update(**kwargs)</code>","text":"<p>Update extended to also handle mapping values, as a Case expression.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p><code>field={Q_obj: value, ...}, ...</code></p> <code>{}</code> Source code in <code>model_values/__init__.py</code> <pre><code>def update(self, **kwargs) -&gt; int:\n    \"\"\"Update extended to also handle mapping values, as a [Case][model_values.Case] expression.\n\n    Args:\n        **kwargs: `field={Q_obj: value, ...}, ...`\n    \"\"\"\n    for field, value in kwargs.items():\n        if Case.isa(value):\n            kwargs[field] = Case(value, default=F(field))\n    return super().update(**kwargs)\n</code></pre>"},{"location":"reference/#model_values.QuerySet.value_counts","title":"<code>value_counts(alias='count')</code>","text":"<p>Return annotated value counts.</p> Source code in <code>model_values/__init__.py</code> <pre><code>def value_counts(self, alias: str = 'count') -&gt; QuerySet:\n    \"\"\"Return annotated value counts.\"\"\"\n    return self.select(*self._fields, **{alias: F.count()})\n</code></pre>"},{"location":"reference/#model_values.Manager","title":"<code>model_values.Manager</code>","text":"<p>               Bases: <code>Manager</code></p> Source code in <code>model_values/__init__.py</code> <pre><code>class Manager(models.Manager):\n    def get_queryset(self):\n        return QuerySet(self.model, Query(self.model), self._db, self._hints)\n\n    def __getitem__(self, pk) -&gt; QuerySet:\n        \"\"\"Return [QuerySet][model_values.QuerySet] which matches primary key.\n\n        To encourage direct db access, instead of always using get and save.\n        \"\"\"\n        return self.filter(pk=pk)\n\n    def __delitem__(self, pk):\n        \"\"\"Delete row with primary key.\"\"\"\n        self[pk].delete()\n\n    def __contains__(self, pk):\n        \"\"\"Return whether primary key is present using `exists`.\"\"\"\n        return self[pk].exists()\n\n    def upsert(self, defaults: Mapping = {}, **kwargs) -&gt; int | models.Model:\n        \"\"\"Update or insert returning number of rows or created object.\n\n        Faster and safer than `update_or_create`.\n        Supports combined expression updates by assuming the identity element on insert:  `F(...) + 1`.\n\n        Args:\n            defaults: optional mapping which will be updated, as with `update_or_create`.\n        \"\"\"\n        update = getattr(self.filter(**kwargs), 'update' if defaults else 'count')\n        for field, value in defaults.items():\n            expr = isinstance(value, models.expressions.CombinedExpression)\n            kwargs[field] = value.rhs.value if expr else value\n        try:\n            with transaction.atomic():\n                return update(**defaults) or self.create(**kwargs)\n        except IntegrityError:\n            return update(**defaults)\n\n    def bulk_changed(self, field, data: Mapping, key: str = 'pk') -&gt; dict:\n        \"\"\"Return mapping of values which differ in the db.\n\n        Args:\n            field: value column\n            data: `{pk: value, ...}`\n            key: unique key column\n        \"\"\"\n        rows = self.filter(F(key).isin(data))[key, field].iterator()\n        return {pk: value for pk, value in rows if value != data[pk]}\n\n    def bulk_change(\n        self, field, data: Mapping, key: str = 'pk', conditional=False, **kwargs\n    ) -&gt; int:\n        \"\"\"Update changed rows with a minimal number of queries, by inverting the data to use `pk__in`.\n\n        Args:\n            field: value column\n            data: `{pk: value, ...}`\n            key: unique key column\n            conditional: execute select query and single conditional update;\n                may be more efficient if the percentage of changed rows is relatively small\n            **kwargs: additional fields to be updated\n        \"\"\"\n        if conditional:\n            data = {pk: data[pk] for pk in self.bulk_changed(field, data, key)}\n        updates = collections.defaultdict(list)\n        for pk in data:\n            updates[data[pk]].append(pk)\n        if conditional:\n            kwargs[field] = {F(key).isin(tuple(updates[value])): value for value in updates}\n            return self.filter(F(key).isin(data)).update(**kwargs)\n        count = 0\n        for value in updates:\n            kwargs[field] = value\n            count += self.filter((F(field) != value) &amp; F(key).isin(updates[value])).update(**kwargs)\n        return count\n</code></pre>"},{"location":"reference/#model_values.Manager.__contains__","title":"<code>__contains__(pk)</code>","text":"<p>Return whether primary key is present using <code>exists</code>.</p> Source code in <code>model_values/__init__.py</code> <pre><code>def __contains__(self, pk):\n    \"\"\"Return whether primary key is present using `exists`.\"\"\"\n    return self[pk].exists()\n</code></pre>"},{"location":"reference/#model_values.Manager.__delitem__","title":"<code>__delitem__(pk)</code>","text":"<p>Delete row with primary key.</p> Source code in <code>model_values/__init__.py</code> <pre><code>def __delitem__(self, pk):\n    \"\"\"Delete row with primary key.\"\"\"\n    self[pk].delete()\n</code></pre>"},{"location":"reference/#model_values.Manager.__getitem__","title":"<code>__getitem__(pk)</code>","text":"<p>Return QuerySet which matches primary key.</p> <p>To encourage direct db access, instead of always using get and save.</p> Source code in <code>model_values/__init__.py</code> <pre><code>def __getitem__(self, pk) -&gt; QuerySet:\n    \"\"\"Return [QuerySet][model_values.QuerySet] which matches primary key.\n\n    To encourage direct db access, instead of always using get and save.\n    \"\"\"\n    return self.filter(pk=pk)\n</code></pre>"},{"location":"reference/#model_values.Manager.bulk_change","title":"<code>bulk_change(field, data, key='pk', conditional=False, **kwargs)</code>","text":"<p>Update changed rows with a minimal number of queries, by inverting the data to use <code>pk__in</code>.</p> <p>Parameters:</p> Name Type Description Default <code>field</code> <p>value column</p> required <code>data</code> <code>Mapping</code> <p><code>{pk: value, ...}</code></p> required <code>key</code> <code>str</code> <p>unique key column</p> <code>'pk'</code> <code>conditional</code> <p>execute select query and single conditional update; may be more efficient if the percentage of changed rows is relatively small</p> <code>False</code> <code>**kwargs</code> <p>additional fields to be updated</p> <code>{}</code> Source code in <code>model_values/__init__.py</code> <pre><code>def bulk_change(\n    self, field, data: Mapping, key: str = 'pk', conditional=False, **kwargs\n) -&gt; int:\n    \"\"\"Update changed rows with a minimal number of queries, by inverting the data to use `pk__in`.\n\n    Args:\n        field: value column\n        data: `{pk: value, ...}`\n        key: unique key column\n        conditional: execute select query and single conditional update;\n            may be more efficient if the percentage of changed rows is relatively small\n        **kwargs: additional fields to be updated\n    \"\"\"\n    if conditional:\n        data = {pk: data[pk] for pk in self.bulk_changed(field, data, key)}\n    updates = collections.defaultdict(list)\n    for pk in data:\n        updates[data[pk]].append(pk)\n    if conditional:\n        kwargs[field] = {F(key).isin(tuple(updates[value])): value for value in updates}\n        return self.filter(F(key).isin(data)).update(**kwargs)\n    count = 0\n    for value in updates:\n        kwargs[field] = value\n        count += self.filter((F(field) != value) &amp; F(key).isin(updates[value])).update(**kwargs)\n    return count\n</code></pre>"},{"location":"reference/#model_values.Manager.bulk_changed","title":"<code>bulk_changed(field, data, key='pk')</code>","text":"<p>Return mapping of values which differ in the db.</p> <p>Parameters:</p> Name Type Description Default <code>field</code> <p>value column</p> required <code>data</code> <code>Mapping</code> <p><code>{pk: value, ...}</code></p> required <code>key</code> <code>str</code> <p>unique key column</p> <code>'pk'</code> Source code in <code>model_values/__init__.py</code> <pre><code>def bulk_changed(self, field, data: Mapping, key: str = 'pk') -&gt; dict:\n    \"\"\"Return mapping of values which differ in the db.\n\n    Args:\n        field: value column\n        data: `{pk: value, ...}`\n        key: unique key column\n    \"\"\"\n    rows = self.filter(F(key).isin(data))[key, field].iterator()\n    return {pk: value for pk, value in rows if value != data[pk]}\n</code></pre>"},{"location":"reference/#model_values.Manager.upsert","title":"<code>upsert(defaults={}, **kwargs)</code>","text":"<p>Update or insert returning number of rows or created object.</p> <p>Faster and safer than <code>update_or_create</code>. Supports combined expression updates by assuming the identity element on insert:  <code>F(...) + 1</code>.</p> <p>Parameters:</p> Name Type Description Default <code>defaults</code> <code>Mapping</code> <p>optional mapping which will be updated, as with <code>update_or_create</code>.</p> <code>{}</code> Source code in <code>model_values/__init__.py</code> <pre><code>def upsert(self, defaults: Mapping = {}, **kwargs) -&gt; int | models.Model:\n    \"\"\"Update or insert returning number of rows or created object.\n\n    Faster and safer than `update_or_create`.\n    Supports combined expression updates by assuming the identity element on insert:  `F(...) + 1`.\n\n    Args:\n        defaults: optional mapping which will be updated, as with `update_or_create`.\n    \"\"\"\n    update = getattr(self.filter(**kwargs), 'update' if defaults else 'count')\n    for field, value in defaults.items():\n        expr = isinstance(value, models.expressions.CombinedExpression)\n        kwargs[field] = value.rhs.value if expr else value\n    try:\n        with transaction.atomic():\n            return update(**defaults) or self.create(**kwargs)\n    except IntegrityError:\n        return update(**defaults)\n</code></pre>"},{"location":"reference/#model_values.Case","title":"<code>model_values.Case</code>","text":"<p>               Bases: <code>Case</code></p> <p><code>Case</code> expression from mapping of when conditionals.</p> <p>Parameters:</p> Name Type Description Default <code>conds</code> <p><code>{Q_obj: value, ...}</code></p> required <code>default</code> <p>optional default value or <code>F</code> object</p> required Source code in <code>model_values/__init__.py</code> <pre><code>class Case(models.Case):\n    \"\"\"`Case` expression from mapping of when conditionals.\n\n    Args:\n        conds: `{Q_obj: value, ...}`\n        default: optional default value or `F` object\n    \"\"\"\n\n    types = {\n        str: models.CharField,\n        int: models.IntegerField,\n        float: models.FloatField,\n        bool: models.BooleanField,\n    }\n\n    def __new__(cls, conds: Mapping, default=None, **extra):\n        cases = (models.When(cond, Value(conds[cond])) for cond in conds)\n        return models.Case(*cases, default=Value(default), **extra)\n\n    @classmethod\n    def defaultdict(cls, conds):\n        conds = dict(conds)\n        return cls(conds, default=conds.pop('default', None))\n\n    @classmethod\n    def isa(cls, value):\n        return isinstance(value, Mapping) and any(isinstance(key, models.Q) for key in value)\n</code></pre>"},{"location":"reference/#model_values.classproperty","title":"<code>model_values.classproperty</code>","text":"<p>               Bases: <code>property</code></p> <p>A property bound to a class.</p> Source code in <code>model_values/__init__.py</code> <pre><code>class classproperty(property):\n    \"\"\"A property bound to a class.\"\"\"\n\n    def __get__(self, instance, owner):\n        return self.fget(owner)\n</code></pre>"},{"location":"reference/#model_values.EnumField","title":"<code>model_values.EnumField(enum, display=None, **options)</code>","text":"<p>Return a <code>CharField</code> or <code>IntegerField</code> with choices from given enum.</p> <p>By default, enum names and values are used as db values and display labels respectively, returning a <code>CharField</code> with computed <code>max_length</code>.</p> <p>Parameters:</p> Name Type Description Default <code>display</code> <code>Callable | None</code> <p>optional callable to transform enum names to display labels, thereby using enum values as db values and also supporting integers.</p> <code>None</code> Source code in <code>model_values/__init__.py</code> <pre><code>def EnumField(enum, display: Callable | None = None, **options) -&gt; models.Field:\n    \"\"\"Return a `CharField` or `IntegerField` with choices from given enum.\n\n    By default, enum names and values are used as db values and display labels respectively,\n    returning a `CharField` with computed `max_length`.\n\n    Args:\n        display: optional callable to transform enum names to display labels,\n            thereby using enum values as db values and also supporting integers.\n    \"\"\"\n    choices = tuple((choice.name, choice.value) for choice in enum)\n    if display is not None:\n        choices = tuple((choice.value, display(choice.name)) for choice in enum)\n    try:\n        max_length = max(map(len, dict(choices)))\n    except TypeError:\n        return models.IntegerField(choices=choices, **options)\n    return models.CharField(max_length=max_length, choices=choices, **options)\n</code></pre>"}]}